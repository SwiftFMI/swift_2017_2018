# Лекция №8 (17.05.2018)
--
В тази лекция ще разгледаме вътрешната организация на паметта, когато пишем нашата програма, за да можем да спазваме законите, определени от Swift. Така приложенията ще могат да пестят системни ресурси и да работят по-бързо. Също така ще обърнем внимание на шабноните (функции, класове, структури и изброими типове) в Swift.

## Кога можем да говорим за паметта?

Всяка програма използва памет. Образно можем да си мислим, че това е работната площадка на компютъра (процесора му) и той чете данни от там и ги записва там. Ние като потребители на тази умна система трябва да спазваме правилата, за да може да използваме всички ресурси, които тя ни предоставя. Ако разхищаваме и не следваме правилата, вероятността да стигнем до непредсказуемо състояние е голяма.

Променливите, които ползваме в нашите програми до сега, се пазят в паметта. В зависимост вида им, те се съхраняват в различни части от паметта. Стойностните типове се записват в програмния стек - това е памет, която се управлява от Swift автоматично. Ние нямаме контрол над нея. Приемаме, че Swift се грижи вместо нас. По-интересни са референтните типове, които се записват в хийп-а. Това е друга памет, която се използва за съхранение на големи обеми от данни. Можем да си мислим, че е неизчерпаема, понеже операционната система има механизми, чрез които може да я разширява, но все пак е с крайно голям обем.

Важно е да знаем, че класовете са референтни типове. Те се заделят в хийпа (този тип памет) и имаме референция (знание, къде се намират в паметта) към тях.

## ARC (Automatic Reference Counting)

Това е механизмът, който се ползва от Swift за управление на паметта.

Една инстанция се пази в паметта докато има референции към нея. Ако няма повече референции, тогава тя бива деинициализирана. Стандартните референции са силни референции (strong), защото задържат паметта сочена от тях и тя няма да бъде деинициализирана.

Можем да говорим за ARC при класовете (т.е. референтните типове) и клоужърите. Типовете, които се предават по стойнонст като структури и изброими типове, не са част от ARC управлението на паметта. Те се управляват от друг различен механизъм, които приемаме за даденост.

### Защо ни трябва автоматично управление?

Автоматичното управление на паметта ни позволява да се фокусриаме над истинските проблеми, а не над управлението на паметта в компютъра. Има различни механизми за управление на памет. Първият - най-базовият е ръчно управление на памет. Среща се в езиците като C, C++. Характерно е, че всяка динамично заделена инстанция заема памет и тази памет трябва експлицитно да бъде освободена след като няма да бъде използвана за напред. Второ ниво на автоматизиране е ARC (механизмът използван от Swift).  Характерно за него е, че всяка истанция знае броя референции към нея. Т.е. ако имам две променливи, които сочат конкретна инстанция, то тази инстанция знае, че има поне две референции. Освобождаването на паметта настъпва автоматично, когато броят на референциите стане равен на нула и вече никой няма да използва обекта. Последното ниво на автоматизация (пълна автоматизация) е механизъм, който разчита на garbage collector (гарбидж-колектор). Това е алгоритъм, който се грижи за автоматичното разпознаване на ненужните обекти и освобождаването им. Предимството му е, че програмистът не трябва да се занимава с управлението на паметта - което не е напълно вярно за ARC. Непредсказуемостта му на изпълнение (кога ще се стартира) е основен недостатък.

За да илюстрираме освобождаването на памет, ще отпечатване текст при автоматичното извикване не 
deinit метода на класа.

```swift
class Car {
    private var name:String
    
    init(name:String) {
        self.name = name
        print("Initalize a car instance with name: \(name)")
    }
    
    deinit {
        print("Deinit a car instance with name \(self.name) ")
    }
}
    
var tesla:Car? = Car(name: "Tesla")
tesla = nil

```
### Алокиране и деалокиране
Заделянето на памет настъпва когато инициализраме нова инстанция - обект от даден тип. Това става, когато неявно извикаме `init` метода на един клас.

Освобождаването на заетата памет става, когато нямаме повече референции към даден обект. Това е факт, когато занулим съответните променливи, както в примера по горе.

В общия случай ARC се справя с управлението на паметта, с изключения когато се получи цикъл от референции. Тогава броячите на всяка инстанция не стигат до 0 и паметта не може да бъде освободена.

Точно такива цикли са причината за memory leak-ове ("изтичане на памет"). Следва пример, който илюстрира цикъл от референции.

Сега ще дадем пример за референтен цикъл. 

Нека да реализираме следните два класа: 

- Книга (има точно един автор)
- Автор (има точно една книга)

Това е частен случай на реалността, но е напълно достатъчен да покаже проблема.

```swift
class Book {
    let title:String
    let author:Author
    var genre:String?
    var pages:Int = 0
    
    init(title:String, author:Author) {
        self.title = title
        self.author = author
    }
    
    deinit {
        print("Deinit a book instance with title \(self.title) ")
    }
}

class Author {
    let name:String
    //трябва да добавим weak пред пропъртито, за да
    //можем да прекъснем цикъла
    //weak var book:Book?
    var book:Book?
    var age:Int
    var isAlive:Bool
    
    init(name:String, age:Int, isAlive:Bool) {
        self.name = name
        self.age = age
        self.isAlive = isAlive
    }
    
    deinit {
        print("Deinit an Auhtor instance with name \(self.name) ")
    }
}


var author:Author? = Author(name: "Достоевски",age: 73, isAlive: false)

var book:Book? = Book(title: "53",author:author! )

author!.book = book
//не можем да го прекъснем
book = nil
author = nil
```

Можем да направим следните изводи:

- ARC е добър, когато няма цикли.
- Ако имаме цикли от референции, трябва да използваме съответните механизми, за да ги разрешим.
- ARC има нужда от малка подсказка, за да може да реши проблема.

### Да използваме `weak` референция

`weak` реферeцията е такава, която позволява на ARC да деинициализира променливата, сочена от референцията. В резултат на това, тази променлива има стойност `nil`. Не можем да направим константа и типът е винаги опционален (optional).
Трябва да използваме такава референция, когато реферираният елемент може да бъде заменен.

Наблюдателите (observers) на пропъртита не се активират, когато ARC промени стойността на `nil`.

При езиците с гарбидж-колектор (алтернативен механизъм на ARC) weak референциите имат друго значение. Те често се ползват, когато се реализира кеш от обекти, който трябва да се освободи, само когато няма достатъчно памет. Освобождаването се извършва от гарбидж-колектора. При ARC `weak` се различава и не може да бъде ползвана по този начин, тъй като референциите(паметта) биват освободени веднага.

### Да използваме `unowned` референция

 `unowned` реферeнцията е такава, която позволява на ARC да деинициализира променливата, но тук интересното е, че 'дължината на живот' на тази променлива е същата или по-дълга. Т.е. няма да има случай в който тя да сочи към мястото в паметта, а то да е `nil`.

Трябва да се използва `unowned` когато сме сигурни, че референцията ще сочи инстанция, която няма да е деинициализирана. Ако се опитате да достъпите такава инстанция ще се получи грешка при изпълнение (runtime грешка).
Ето и пример, който можем да разрешим с помощта на `unowned` модификатора.

Да се реализира примерна йерархия:

- Студент (който има студентска книжка)
- Студентска книжка (StudentCard, която има студент)

```swift
class Student {
    let name: String
    var age = 19
    var card:StudentCard?
    
    init(name:String, age:Int) {
        self.name = name
        self.age = age
        print("Init a student instance.")
    }
    
    func printStrudent() {
        print("Name: \(name) ")
        print("Age: \(age) ")
    }
    
    deinit {
        print("deInit a student instance")
    }
}

class StudentCard {
    let university: String
    let number: String
    
    
//    unowned(unsafe) let student:Student
//    unowned let student:Student
    let student:Student
    
    init(uni:String, number:String, student:Student) {
        university = uni
        self.number = number
        self.student = student
    }
    
    deinit {
        print("deInit a student-card instance - \(self.number)")
    }
}
```

Можем да използваме варианта `unowned(unsafe)`, където проверката дали паметта не е занулена, е изключена. Този вариант е по-бърз от стандартния, но носи рискове в случаите, когато инстанцията е деалокирана.

Референтни цикли можем да получим когато използваме и други референтни типове, примерно клоужъри.

## Цикли от референции при клоужъри (closures)

Понеже тялото на клоужър (closure) запомня (capture) променливи и ако го използваме в клас - запомня `self`, тогава можем да стигнем до цикъл. Тъй като клоужърите и те са референтен тип, те могат да образуват цикъл от референции.

Сега ще разгледаме следния пример:

```swift
class DataType {
    let name:String
    var properties: Array<String> //[String]
    
    let prettyPrint = true
    
    init(name:String) {
        self.name = name
        properties = []
    }
    
    lazy var toSwift: () -> String = {
    //списъка с променливите в клоужъра ни
    //позволява да упражним допълнителен контрол
//        [unowned self, name = self.name] in

        var swiftCode:String = "class \(self.name) {"
        
        if self.prettyPrint {
            swiftCode += "\n"
        }
        
        for property in self.properties {
            if self.prettyPrint {
                swiftCode += "\t"
            }
            swiftCode += property
        }
        
        if self.prettyPrint {
            swiftCode += "\n"
        }
        
        swiftCode += "}"
        
        return swiftCode
    }
    
    deinit {
        print("Deinit dataType instance \(self.name)")
    }
}

var student:DataType? = DataType(name: "Student")
student?.properties.append("var name:String = \"Без име\"")
print(student!.toSwift())
student = nil
```

За да решим проблема трябва да използваме списъка с променливите, които клоужъра зaпомня и да ги определим като `unowned` или `weak`. Този списък се нарича capture list - или списък със запомнени променливи, които се използват в тялото на клоужъра. Той позволява добавяне на допълнителни модификатори към променливите и дори дефиниране на нови, които пази клоужъра.

Ето и един пример, който показва каква е разликата между клоужър с и без такъв списък.

```swift
var myA = 0
var myB = 0

let f: () -> () = { [myA] in
    print("A = \(myA)")
    print("B = \(myB)")
}
    

myA = 7
myB = 7

f()

//A = 0
//B = 7
```

На базата на примера можем да направим промяна, като добавим `[unowned self]` преди параметрите на клоужъра.

# Шаблони
--

Щаблоните позволяват да прилагаме общо решение на проблем към частни проблеми. Това редуцира количеството код, което трябва да пишем, но от друга страна повишава трудността да дизайнваме шаблонни решения.

## Какъв проблем решават шаблоните?

Как да напишем една фукнция, която има различни форми само веднъж и тя да може да се използва в различни моменти.

## Шаблонни функции

Това са функции, които заместват конкретни имплементации на други функции. Примерно, можем да дефинираме шаблонна функция, която "събира" два обекта от определен тип. Типовете, над които може да бъде приложена функцията, трябва да имат имплементирана операцията "+".

### Трябва да използваме шаблонните типове

Шаблонните типове се заместват с типове от вида T, K, U, като винаги са с главна буква и ако имат някаква релация, може да се използват думи, които да подсказват релацията. Пример: `Dictionary<Key, Value>`

Шаблоните се добавят след името на функцията в `< >` скоби. После този тип, който е шаблонен се използва въе функцията, за да се определи типа на параметрите и типа на връщания резултат.

Ето и един пример:

```swift
protocol Sumable {
    static func + (left: Self, right:Self) -> Self
    
}

// изискванията, които поставя тази темплейтна функция са:
// 1. двата параметъра да са от един тип
// 2. резултатът да е от същия тип
// 3. типът да има реализирана операция + или събирането да е дефинирано. Това става, чрез наложеното ограничение в темплейтите

func sum<T:Sumable>(_ a:T, _ b: T) -> T {
    return a + b
}


struct Vector:Sumable {
   var x = 10
    
    static func + (left: Vector, right:Vector) -> Vector {
        return Vector(x: left.x + right.x)
    }
}

let vX = Vector(x: 10)
let vY = Vector(x: 10)
let sumV = sum(vX, vY)

extension String:Sumable {}
let hw  = sum("Hello ", "World!")
```

Можем да ползваме шаблоните не само при функциите, но и при дефинирането на нови класове.

## Шаблонни класове

Шаблонните класове наподобяват шаблонните функции, защото шаблонните типове се задават пак в `< >` скоби след името на класа.

Можем да дефинираме и шаблонни протоколи, като използваме запазената дума: `associatedtype`.

Ето и един пример:
```swift
protocol CollectionEquatable {
    associatedtype Element
    var count:Int { get }
    subscript (i:Int) -> Element {get}
}
```

Това е протокол, който трябва да борави с шаблонен тип `Element`. Така определената версия на протокола, може да конкретизира типа, който ще се свърже с `Element`. Т.е. навсякъде вместо този тип, ще се използва конкретния валиден тип.

Ето и пример за шаблонна опашка:

```swift
class Queue<Item>:CollectionEquatable {
    var items:[Item]
    
    init() {
        items = []
    }
    
    func insert(item:Item) {
       items.append(item)
    }
    
    func get() -> Item? {
        if items.count > 0 {
            return items.removeFirst()
        }
        
        return nil
    }
    
    subscript (i:Int) -> Item {
        return items[i]
    }
    
    var count:Int {
        return items.count
    }
}

extension Array : CollectionEquatable {}
```

Нека сега да напишем шаблонна функция, която сравнява две колекции, които могат да бъдат сравнявани по следните правила:
1. Двете колекции трябва да имплментират протокола `CollectionEquatable`
2. Да имат еднакъв брой елементи
3. Всеки елемент да е еднакъв на съответния елемент от другата колекция

Ето и код, който илюстрира това:

```swift
func isEqual<T:CollectionEquatable, U:CollectionEquatable>(left:T, right:U) -> Bool where T.Element:Equatable, U.Element == T.Element {
    if left.count == right.count {
        for i in 0..<right.count {
            if left[i] != right[i] {
                return false
            }
        }
        
        return true
    }
    
    return false
}
```
Функцията има `WHERE`, чрез която се задава зависимостта елементите на всяка колекция да са от един и същи тип -  `U.Element == T.Element` и типът на тези елементи да позволява да сравняване обекти.

Тези ограничения са важни, за да можем да запишем коректно условията в тялото на функцията. Важно е да има два типа, за да позволим различни типове колекции, които имплементират този интерфейс да могат да бъдат сравнявани - `<T:CollectionEquatable, U:CollectionEquatable>`.
`T.Element:Equatable` и `U.Element == T.Element` ни позволява да напишем `left[i] != right[i]`, понеже елементите ще са от един и същи тип и този тип ще е сравним.

Добре е да знаем, че можем да използваме разширения, за да добавяме допълнителни функции към шаблонните класове.

Ограниченията над шаблонните класове ги задаваме по няколко различни начина:

- чрез протоколи, които трябва да бъдат имплементирани от класовете. (Добре е да си припомним, че можем да фиксираме даден протокол да се имплементира само от класове)
- чрез `WHERE` клауза и зависимости между класовете.
- чрез `associatedtype` и протоколи
 
### Асоциирани типове и протоколи 

Трябва да използваме `associatedtype Element` като част от протокола. В последствие, можем да използваме типа `Element`.

При имплементиране на определен протокол с асоцииран тип, Swift сам успява да определи реалният тип, с който трябва да замести асоциацията. Т.е. `Element` с кой реален тип трябва да бъде заместен.
 
### Where условия при шаблоните

Условието трябва да се добави преди началото на функцията или типа от данни, които описваме. Може да видите правилото в действие в кода по-горе.


# Атрибути *
--
Вече сме се сблъсквали с няколко приложения на атрибутите. Добре е да разберем тяхното основно приложение.

## За какво се ползват атрибутите

Това е механизъм, който добавя допълнителна информация към декларация или към тип. В Swift се използват за да дадем допълнителна информация за параметрите на функция.
Ето и пример:

```swift
func funcAutoclosureComplex(pred: @autoclosure () -> ()) {
    print("body of \(#function)")
}
```

Общият вид е следния:

```swift
@attributeName
//или
@attributeName(attribute arguments)
```

## Популярни атрибути 

Популярните атрибути, които можете да срещнете в Swift код са:

- available - използва се да покажем даден метод от кога е достъпен. За коя платформа и от коя версия:
```swift 
@available(platformName versionNumber, *)
//пример
@available(iOS 10.1, macOS 10.12, *)
```
- discardableResult - прилага се при функции, за да не се изписва предупреждението, когато резултата от функцията не се използва.
- GKInspectable - използва се при атрибути, които са свързани с iOS фреймуорка SpriteKit.
- objc - използва се, когато искаме да направим код-а от swift достъпен за obj-C. Има своите специфики.
- nonobjc - използва се, когато задължително искаме да скрием декларация от Obj-C.
- NSApplicationMain - прилага се към основният делегат. Приложимо е в iOS.

Атрибутите, които се прилагат над параметрите са:

- escaping - добре познат атрибут свързан с клоужърите. Трябва да се използва в случай, когато клоужъра ще напусне функцията.
- autoclosure - конвертира израза в клоужър
- convention - изполва се, когато се смесват различни типове функции - objc, c или swift

```swift
//int (*)(void) in C 
//in Swift looks like this
@convention(c) () -> Int32
```
Повече информация може да намерите в официалната документация от Apple (https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html).

-- 
* <sup><sup>няма да е част от теста</sup></sup>

